<# // Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. #>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"TableSpec.xml")).Root;
var xmlns = "http://IxMilia.com/Dxf/TableSpec";
var tables = xml.Elements(XName.Get("Table", xmlns));
#>
// Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System.Linq;
using System.Collections.Generic;
using IxMilia.Dxf.Sections;

namespace IxMilia.Dxf.Tables
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                tables
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
    var tableItem = Name(table.Element(XName.Get("TableItem", xmlns)));
#>

    public partial class Dxf<#= Type(table) #>Table : DxfTable
    {
        internal override DxfTableType TableType { get { return DxfTableType.<#= Type(table) #>; } }
        public List<<#= tableItem #>> Items { get; private set; }

        protected override IEnumerable<DxfSymbolTableFlags> GetSymbolItems()
        {
            return Items;
        }

        public Dxf<#= Type(table) #>Table()
        {
            Items = new List<<#= tableItem #>>();
        }

        internal static DxfTable ReadFromBuffer(DxfCodePairBufferReader buffer)
        {
            var table = new Dxf<#= Type(table) #>Table();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                buffer.Advance();
                if (DxfTablesSection.IsTableEnd(pair))
                {
                    break;
                }

                if (pair.Code == 0 && pair.StringValue == DxfTable.<#= TypeString(table) #>)
                {
                    var item = <#= tableItem #>.FromBuffer(buffer);
                    table.Items.Add(item);
                }
            }

            return table;
        }
    }
<#
}
#>
}

namespace IxMilia.Dxf
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           table items
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
    var tableItem = table.Element(XName.Get("TableItem", xmlns));
    var properties = tableItem.Elements(XName.Get("Property", xmlns));
#>

    public partial class <#= Name(tableItem) #> : DxfSymbolTableFlags
    {
        internal const string AcDbText = "<#= ClassName(tableItem) #>";

        protected override string TableType { get { return Tables.DxfTable.<#= TypeString(table) #>; } }

        // properties
<#
    foreach (var property in properties)
    {
        var propertyType = Type(property);
        if (AllowMultiples(property))
            propertyType = string.Format("List<{0}>", propertyType);
#>
        public <#= propertyType #> <#= Name(property) #> { get; set; }
<#
    } // foreach (var property in properties)

#>

        public <#= Name(tableItem) #>()
            : base()
        {
<#
    foreach (var property in properties)
    {
        var defaultValue = DefaultValue(property);
        if (AllowMultiples(property))
            defaultValue = string.Format("new List<{0}>()", Type(property));
#>
            <#= Name(property) #> = <#= defaultValue #>;
<#
    } // foreach (var property in properties)

#>
        }

        internal override void AddValuePairs(List<DxfCodePair> pairs)
        {
            pairs.Add(new DxfCodePair(100, AcDbText));
            pairs.Add(new DxfCodePair(2, Name));
<#
    if (HasFlags(tableItem))
    {
#>
            pairs.Add(new DxfCodePair(70, (short)Flags));
<#
    } // has flags
    foreach (var property in properties)
    {
        if (AllowMultiples(property))
        {
#>
            pairs.AddRange(<#= Name(property) #>.Select(value => new DxfCodePair(<#= Code(property) #>, value)));
<#
        }
        else
        {
            var codeOverrides = CodeOverrides(property);
            if (Code(property) < 0 && codeOverrides != null)
            {
                char prop = 'X';
                for (int i = 0; i < codeOverrides.Length; i++, prop++)
                {
#>
            pairs.Add(new DxfCodePair(<#= codeOverrides[i] #>, <#= Name(property) #>.<#= prop #>));
<#
                }
            }
            else
            {
#>
            pairs.Add(new DxfCodePair(<#= Code(property) #>, <#= WriteConverter(property) #>(<#= Name(property) #>)));
<#
            }
        }
    } // foreach (var property in properties)
#>
        }

        internal static <#= Name(tableItem) #> FromBuffer(DxfCodePairBufferReader buffer)
        {
            var item = new <#= Name(tableItem) #>();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                if (pair.Code == 0)
                {
                    break;
                }

                buffer.Advance();
                switch (pair.Code)
                {
                    case 2:
                        item.Name = pair.StringValue;
                        break;
<#
    if (HasFlags(tableItem))
    {
#>
                    case 70:
                        item.Flags = (int)pair.ShortValue;
                        break;
<#
    } // has flags
    foreach (var property in properties)
    {
        var codeOverrides = CodeOverrides(property);
        if (Code(property) < 0 && codeOverrides != null)
        {
            char prop = 'X';
            for (int i = 0; i < codeOverrides.Length; i++, prop++)
            {
                var codeType = DxfCodePair.ExpectedType(codeOverrides[i]);
                var codeTypeValue = TypeToString(codeType);
#>
                    case <#= codeOverrides[i] #>:
                        item.<#= Name(property) #>.<#= prop #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
            }
        }
        else
        {
            var code = Code(property);
            var codeType = DxfCodePair.ExpectedType(code);
            var codeTypeValue = TypeToString(codeType);
            if (AllowMultiples(property))
            {
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #>.Add(<#= ReadConverter(property) #>(pair.<#= codeTypeValue #>));
                        break;
<#
            }
            else
            {
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
            }
        }
    } // foreach (var property in properties)
#>
                }
            }

            return item;
        }
<#
#>
    }
<#
} // foreach (var table in tables)
#>
}
<#@ include file="$(ProjectDir)\DxfCommon.t4" #>
